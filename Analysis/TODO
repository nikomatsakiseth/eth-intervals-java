TODO LIST
=========

Bugs and ToDos
--------------

(*) Enforce that ghost fields cannot be shadowed (nor be shadowed by reified fields).

(*) Make supertypes ERASED, and add "ghost defns" to the class that apply equally?
    Or is that a front-end issue?  Not really, because it comes up with interfaces and 
    the like.

(*) Enforce that if there are not multiple paths with different values for a given ghost field.
    Or is that ok?

(*) Add assumption (and validate) that all field and ghost names are GLOBALLY unique
    (in other words, prefix them with the class in the preprocessor).  Alternatively,
    make substitution smarter.  Trying to avoid this kind of problem:
    
        class Type2<Interval g> 
        extends Type1<this.constructor> {
            ...
        }
        
        class Type1<Interval g> ...
    
        void mthd1(Type1 arg)
        requires arg.g subinterval this
        {...}
        
        {
            ...
            Type2<y> x;
            mthd1(x);
            ...
        }
        
    mthd1 is referring to Type1::g (i.e., x.constructor), but if we're not careful when
    we substitute arg for x in the call, we might end up referring to Type2::g (i.e., y)!
    To make this sound, we really need to upcast the type of arg to its static type and 
    substitute both arg→x and arg.g→x.constructor; alternatively, if ghost names were
    unique, we could resolve ghost names more like fields.  The latter solution seems a bit
    more robust to me.  Although, if we always built substitutions by giving a pair like
        Wt_x x → Wt_y y
    where (Wt_x <: Wt_y) we could encapsulate the "best practices" in one method.
    
    Note that making building ghost fields into the inheritance hierarchy is actually 
    the model I intend to present to the user.  There is therefore a strong case that
    it will make it easier to report errors if the model of the type checker precisely
    matches the user model, rather than merely being equivalent to.  Think how confusing
    it could be to report errors...
    
    In that case, types would change from having a fixed list of parameters to a map
    (just like is being presented to the user).  When a ghost field is found, we would
    check the type to see if there are any mappings for that field defined.  If not,
    then foo.g is used (ie, defaults to completely unknown).  Actually seems quite nice!
    
(*) Check in multiple inheritance that all paths lead to the same set of ghost 
    parameters.  Alternatively, make sure that we all paths are fulfilled.
    Latter technique is "cooler" (then, for ex., a class modelling an empty set
    can fulfill virtually any type, etc)
    
(*) Sanity check casts or otherwise restrict them?

Features
--------

(*) Control-flow: convert to SSA or SSI form.

(*) @Is annotations on methods and variable declarations

(*) Inherit assumptions from supertype constructors as well!

(*) Ensures declarations-- (?)

    In place of the current inference, we should add ensures declarations on constructors
    (or potentially other methods).  These ensures declarations could be inferred by the
    compiler for constructors as we do today, but could also be manually specified to support
    virtual methods and helpers for constructors.
    
(*) Assertions

(*) Javac plugin

(*) Multiple constructors

(*) Allow multiple guards (or a guard predicate of some kind)

    For example, lock AND written during.  This way, you could have shared data accessed by
    locks up to a point, where it becomes read-only without locks.

(*) Allow fields to be guarded by a point?

    In this case, would be write-only before the point, but read-only after the point.
    Clearly racy.

(*) Requires in class bodies, declarations--

    If a class declared, for example, that two of its fields f and g have a HB relationship,
    then this would link f and g.  We can use the existing linked fields mechanisms to ensure
    that they are written together.
        
Things to Think About
---------------------

(*) Cleanup linked field logic as relates to guards.  

    Right now, a field F is not linked to G if guard(G) hb guard(F).  
    The reasoning is that then guard(F) could not yet have occurred, 
    and so F must still be nil, which is valid.  What would prob. 
    make more sense is to say tht F is not linked to G if current hb F.
    
(*) Ordering among fields, parameters, ghosts?  

    We used to have some code that prevented the types of ghosts, fields, method
    parameters, etc from referencing later declarations.  I am not sure
    if there is any good reason for this code.  It may prevent infinite cycles 
    in the type check but I'm not sure where.

(*) Check types of arguments to a type when checking for WF?
    
    Right now, we only check that the ghost arguments on a type 
    are well-typed when checking a "new" statement.  This should be
    sufficient as it would be impossible to ever store a value (other
    than null) into an ill-typed variable, since you could never 
    create an object with that type.

(*) Fields that are modified outside of constructor?

    In the classes Indirect2/Indirect3 defined in the test illegalLinkedFields, 
    we see that indirect dependencies in types are generally disallowed
    but for when we can guarantee that the dependent field is never modified
    until the dependee is constant.  Right now that is only permitted in one case:
    we know that this.constructor hb this if this is an interval.  
    
    In some cases, if/when we add the ability to add more complex requirements,
    we could add have a field f guarded by inter1 and a dependent field g guarded by inter2
    where inter1 hb inter2.  (inter1 would typically be this.constructor)
    
    What might also be desirable, but probably only rarely, would be 
    some way to indicate that a field is not assigned until outside of the contructor.
    This would allow us to treat this.ctor fields as constant.  Hmm, when I started
    writing it, this seemed common, but now I think it probably isn't.