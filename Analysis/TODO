TODO LIST
=========

Bugs and ToDos
--------------

(*) Make supertypes ERASED, and add "ghost defns" to the class that apply equally?
    Or is that a front-end issue?  Not really, because it comes up with interfaces and 
    the like.

(*) Check in multiple inheritance that all paths lead to the same set of ghost 
    parameters.  Alternatively, make sure that all paths are fulfilled.
    Latter technique is "cooler" (then, for ex., a class modelling an empty set
    can fulfill virtually any type, etc)
    
(*) Sanity check casts or otherwise restrict them?

(*) More sophisticated merging with respect to temp/perm

    If all preds have the same effective mapping, but some in temp and some in pred,
    the succ should have the mapping in temp.  for example:
    
    if(...) {
        b = ...; // immutable object
        a = b.f; // permanent!
    } else {
        b = ...; // mutable object
        a = b.f; // temporary
    }
    // safe if b.fâ†’a temporarily
 
Features
--------

(*) @Is annotations on methods and variable declarations

(*) Assertions

    a hb b
    a locks b    
    a readableBy b
    a writableBy b
    a == b              creates a temporary alias from b to a?
    a == b->p           creates a temporary alias from b->p to a

(*) Javac plugin

(*) Requires in class bodies, declarations--

    If a class declared, for example, that two of its fields f and g have a HB relationship,
    then this would link f and g.  We can use the existing linked fields mechanisms to ensure
    that they are written together.
        
Things to Think About
---------------------

(*) Allow multiple guards (or a guard predicate of some kind)

    For example, lock AND written during.  This way, you could have shared data accessed by
    locks up to a point, where it becomes read-only without locks.

(*) Allow fields to be guarded by a point?

    In this case, would be write-only before the point, but read-only after the point.
    Clearly racy.

(*) Ensures declarations-- (?)

    In place of the current inference, we should add ensures declarations on constructors
    (or potentially other methods).  These ensures declarations could be inferred by the
    compiler for constructors as we do today, but could also be manually specified to support
    virtual methods and helpers for constructors.
    
(*) Iterated linked fields

    Right now we screen out linked fields whose guards are known not to
    have happened-- but can we also screen out fields whose guards are
    themselves guarded by intervals that have not happened?  Maybe???
    Does that even make sense????
    
(*) Ordering among fields, parameters, ghosts?  

    We used to have some code that prevented the types of ghosts, fields, method
    parameters, etc from referencing later declarations.  I am not sure
    if there is any good reason for this code.  It may prevent infinite cycles 
    in the type check but I'm not sure where.

(*) Check types of arguments to a type when checking for WF?
    
    Right now, we only check that the ghost arguments on a type 
    are well-typed when checking a "new" statement.  This should be
    sufficient as it would be impossible to ever store a value (other
    than null) into an ill-typed variable, since you could never 
    create an object with that type.

(*) Fields that are modified outside of constructor?

    In the classes Indirect2/Indirect3 defined in the test illegalLinkedFields, 
    we see that indirect dependencies in types are generally disallowed
    but for when we can guarantee that the dependent field is never modified
    until the dependee is constant.  Right now that is only permitted in one case:
    we know that this.constructor hb this if this is an interval.  
    
    In some cases, if/when we add the ability to add more complex requirements,
    we could add have a field f guarded by inter1 and a dependent field g guarded by inter2
    where inter1 hb inter2.  (inter1 would typically be this.constructor)
    
    What might also be desirable, but probably only rarely, would be 
    some way to indicate that a field is not assigned until outside of the contructor.
    This would allow us to treat this.ctor fields as constant.  Hmm, when I started
    writing it, this seemed common, but now I think it probably isn't.